

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Measuring Performance with PStats &mdash; Panda3D Manual</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Panda3D Manual" href="../index.html"/>
        <link rel="up" title="Performance Tuning" href="index.html"/>
        <link rel="next" title="The Rigid Body Combiner" href="the-rigid-body-combiner.html"/>
        <link rel="prev" title="Basic Performance Diagnostics" href="basic-performance-diagnostics.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Panda3D
          

          
          </a>

          
            
            
              <div class="version">
                1.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro/index.html">Introduction to Panda3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programming-with-panda3d/index.html">Programming with Panda3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../distribution/index.html">Distributing Panda3D Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../samples/index.html">Sample Programs in the Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugging/index.html">Debugging</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Performance Tuning</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basic-performance-diagnostics.html">Basic Performance Diagnostics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Measuring Performance with PStats</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-rigid-body-combiner.html">The Rigid Body Combiner</a></li>
<li class="toctree-l2"><a class="reference internal" href="too-many-meshes.html">Performance Issue: Too Many Meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="too-many-state-changes.html">Performance Issue: Too Many State Changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="too-many-text-updates.html">Performance Issue: Too Many Text Updates</a></li>
<li class="toctree-l2"><a class="reference internal" href="too-many-shader-instructions.html">Performance Issue: Too Many Shader Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="excessive-fill.html">Performance Issue: Excessive Fill</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-full.html">Performance Issue: Memory Full</a></li>
<li class="toctree-l2"><a class="reference internal" href="python-calculation.html">Performance Issue: Python Calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="failure-to-garbage-collect.html">Performance Issue: Failure to Garbage Collect</a></li>
<li class="toctree-l2"><a class="reference internal" href="collision-system-misuse.html">Performance Issue: Collision System Misuse</a></li>
<li class="toctree-l2"><a class="reference internal" href="motherboard-integrated-video.html">Performance Issue: Motherboard Integrated Video</a></li>
<li class="toctree-l2"><a class="reference internal" href="too-many-polygons.html">Performance Issue: Too Many Polygons</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Performance Issue: Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../using-c++/index.html">Using C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Panda3D Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building-from-source.html">Building Panda3D from Source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheat-sheets.html">Cheat Sheets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started-on-osx.html">Getting Started on OSX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../more-panda3d-resources.html">More Panda3D Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../thirdparty-licenses.html">Third-party dependencies and license info</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the-irc-channel.html">The IRC Channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Panda3D</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Performance Tuning</a> &raquo;</li>
      
    <li>Measuring Performance with PStats</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/performance-tuning/measuring-performance-with-pstats.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="measuring-performance-with-pstats">
<span id="id1"></span><h1>Measuring Performance with PStats<a class="headerlink" href="#measuring-performance-with-pstats" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quick-introduction">
<h2>QUICK INTRODUCTION<a class="headerlink" href="#quick-introduction" title="Permalink to this headline">¶</a></h2>
<p>PStats is Panda&#8217;s built-in performance analysis tool. It can graph frame rate
over time, and can further graph the work spent within each frame into
user-defined subdivisions of the frame (for instance, app, cull and draw), and
thus can be an invaluable tool in identifying performance bottlenecks. It can
also show frame-based data that reflects any arbitrary quantity other than
time intervals, for instance, texture memory in use or number of vertices
drawn.</p>
<p>The performance graphs may be drawn on the same computer that is running the
Panda client, or they may be drawn on another computer on the same LAN, which
is useful for analyzing fullscreen applications. The remote computer need not
be running the same operating system as the client computer.</p>
<p>To use PStats, you first need to build the PStats server program, which is
part of the Pandatool tree (it&#8217;s called pstats.exe on Windows, and pstats on a
Unix platform). Start by running the PStats server program (it runs in the
background), and then start your Direct/Panda client with the following in
your</p>
<p>Config.prc file:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>want-pstats 1
</pre></div>
</div>
<p>Or, at runtime, issue the Python command:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">PStatClient</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</pre></div>
</div>
<p>startup code:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Includes: pStatClient.h</span>

<span class="k">if</span> <span class="p">(</span><span class="n">PStatClient</span><span class="o">::</span><span class="n">is_connected</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">PStatClient</span><span class="o">::</span><span class="n">disconnect</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">host</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="c1">// Empty = default config var value</span>
<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// -1 = default config var value</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PStatClient</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not connect to PStat server.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Or if you&#8217;re running pview, press shift-S.</p>
<p>Any of the above will contact your running PStats server program, which will
proceed to open a window and start a running graph of your client&#8217;s
performance.</p>
<p>If you have multiple computers available for development, it can be
advantageous to run the pstats server on a separate computer so that the
processing time needed to maintain and update the pstats user interface isn&#8217;t
taken from the program you are profiling. If you wish to run the server on a
different machine than the client, start the server on the profiling machine
and add the following variable to your client&#8217;s Config.prc file, naming the
hostname or IP address of the profiling machine:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>pstats-host profiling-machine-ip-or-hostname
</pre></div>
</div>
<p>If you are developing Python code, you may be interested in reporting the
relative time spent within each Python task (by subdividing the total time
spent in Python, as reported under &#8220;Show Code&#8221;). To do this, add the following
lines to your Config.prc file before you start ShowBase:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>task-timer-verbose 1
pstats-tasks 1
</pre></div>
</div>
<div class="section" id="caveats">
<h3>Caveats<a class="headerlink" href="#caveats" title="Permalink to this headline">¶</a></h3>
<p>OpenGL is asynchronous, which means that function calls aren&#8217;t guaranteed to
execute right away. This can make performance analysis of OpenGL operations
difficult, as the graphs may not accurately reflect the actual time that the
GPU spends doing a certain operation. However, if you wish to more accurately
track down rendering bottlenecks, you may set the following configuration
variable:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>pstats-gpu-timing 1
</pre></div>
</div>
<p>This will enable a new set of graphs that use timer queries to measure how
much time each task is actually taking on the GPU.</p>
<p>If your card does not support it or does not give reliable timer query
information, a crude way of working around this and getting more accurate
timing breakdown, you can set this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>gl-finish 1
</pre></div>
</div>
<p>Setting this option forces Panda to call glFinish() after every major graphics
operation, which blocks until all graphics commands sent to the graphics
processor have finished executing. This is likely to slow down rendering
performance substantially, but it will make PStats graphs more accurately
reflect where the graphics bottlenecks are.</p>
</div>
</div>
<div class="section" id="the-pstats-server-the-user-interface">
<h2>THE PSTATS SERVER (The user interface)<a class="headerlink" href="#the-pstats-server-the-user-interface" title="Permalink to this headline">¶</a></h2>
<p>The GUI for managing the graphs and drilling down to view more detail is
entirely controlled by the PStats server program. At the time of this writing,
there are two different versions of the PStats server, one for Unix and one
for Windows, both called simply pstats. The interfaces are similar but not
identical; the following paragraphs describe the Windows version.</p>
<p>When you run pstats.exe, it adds a program to the taskbar but does not
immediately open a window. The program name is typically &#8220;PStats 5185&#8221;,
showing the default PStats TCP port number of 5185; see &#8220;HOW IT WORKS&#8221; below
for more details about the TCP communication system. For the most part you
don&#8217;t need to worry about the port number, as long as server and client agree
(and the port is not already being used by another application).</p>
<p>Each time a client connects to the PStats server, a new monitor window is
created. This monitor window owns all of the graphs that you create to view
the performance data from that particular connection. Initially, a strip chart
showing the frame time of the main thread is created by default; you can
create additional graphs by selecting from the Graphs pulldown menu.</p>
<div class="section" id="time-based-strip-charts">
<h3>Time-based Strip Charts<a class="headerlink" href="#time-based-strip-charts" title="Permalink to this headline">¶</a></h3>
<p>This is the graph type you will use most frequently to examine performance
data. The horizontal axis represents the passage of time; each frame is
represented as a vertical slice on the graph. The overall height of the
colored bands represents the total amount of time spent on each frame; within
the frame, the time is further divided into the primary subdivisions
represented by different color bands (and labeled on the left). These
subdivisions are called &#8220;collectors&#8221; in the PStats terminology, since they
represent time collected by different tasks.</p>
<p>Normally, the three primary collectors are App, Cull, and Draw, the three
stages of the graphics pipeline. Atop these three colored collectors is the
label &#8220;Frame&#8221;, which represents any remaining time spent in the frame that was
not specifically allocated to one of the three child collectors (normally,
there should not be significant time reported here).</p>
<p>The frame time in milliseconds, averaged over the past three seconds, is drawn
above the upper right corner of the graph. The labels on the guide bars on the
right are also shown in milliseconds; if you prefer to think about a target
frame rate rather than an elapsed time in milliseconds, you may find it useful
to select &#8220;Hz&#8221; from the Units pulldown menu, which changes the time units
accordingly.</p>
<p>The running Panda client suggests its target frame rate, as well as the
initial vertical scale of the graph (that is, the height of the colored bars).
You can change the scale freely by clicking within the graph itself and
dragging the mouse up or down as necessary. One of the horizontal guide bars
is drawn in a lighter shade of gray; this one represents the actual target
frame rate suggested by the client. The other, darker, guide bars are drawn
automatically at harmonic subdvisions of the target frame rate. You can change
the target frame rate with the Config.prc variable pstats-target-frame-rate on
the client.</p>
<p>You can also create any number of user-defined guide bars by dragging them
into the graph from the gray space immediately above or below the graph. These
are drawn in a dashed blue line. It is sometimes useful to place one of these
to mark a performance level so it may be compared to future values (or to
alternate configurations).</p>
<p>The primary collectors labeled on the left might themselves be further
subdivided, if the data is provided by the client. For instance, App is often
divided into Show Code, Animation, and Collisions, where Show Code is the time
spent executing any Python code, Animation is the time used to compute any
animated characters, and Collisions is the time spent in the collision
traverser(s).</p>
<p>To see any of these further breakdowns, double-click on the corresponding
colored label (or on the colored band within the graph itself). This narrows
the focus of the strip chart from the overall frame to just the selected
collector, which has two advantages. Firstly, it may be easier to observe the
behavior of one particular collector when it is drawn alone (as opposed to
being stacked on top of some other color bars), and the time in the
upper-right corner will now reflect just the total time spent within just this
collector. Secondly, if there are further breakdowns to this collector, they
will now be shown as further colored bars. As in the Frame chart, the topmost
label is the name of the parent collector, and any time shown in this color
represents time allocated to the parent collector that is not accounted for by
any of the child collectors.</p>
<p>You can further drill down by double-clicking on any of the new labels; or
double-click on the top label, or the white part of the graph, to return back
up to the previous level.</p>
</div>
<div class="section" id="value-based-strip-charts">
<h3>Value-based Strip Charts<a class="headerlink" href="#value-based-strip-charts" title="Permalink to this headline">¶</a></h3>
<p>There are other strip charts you may create, which show arbitrary kinds of
data per frame other than elapsed time. These can only be accessed from the
Graphs pulldown menu, and include things such as texture memory in use and
vertices drawn. They behave similarly to the time-based strip charts described
above.</p>
</div>
<div class="section" id="piano-roll-charts">
<h3>Piano Roll Charts<a class="headerlink" href="#piano-roll-charts" title="Permalink to this headline">¶</a></h3>
<p>This graph is used less frequently, but when it is needed it is a valuable
tool to reveal exactly how the time is spent within a frame. The PStats server
automatically collects together all the time spent within each collector and
shows it as a single total, but in reality it may not all have been spent in
one continuous block of time.</p>
<p>For instance, when Panda draws each display region in single-threaded mode, it
performs a cull traversal followed by a draw traversal for each display
region. Thus, if your Panda client includes multiple display regions, it will
alternate its time spent culling and drawing as it processes each of them. The
strip chart, however, reports only the total cull time and draw time spent.</p>
<p>Sometimes you really need to know the sequence of events in the frame, not
just the total time spent in each collector. The piano roll chart shows this
kind of data. It is so named because it is similar to the paper music roll for
an old-style player piano, with holes punched down the roll for each note that
is to be played. The longer the hole, the longer the piano key is held down.
(Think of the chart as rotated 90 degrees from an actual piano roll. A player
piano roll plays from bottom to top; the piano roll chart reads from left to
right.)</p>
<p>Unlike a strip chart, a piano roll chart does not show trends; the chart shows
only the current frame&#8217;s data. The horizontal axis shows time within the
frame, and the individual collectors are stacked up in an arbitrary ordering
along the vertical axis.</p>
<p>The time spent within the frame is drawn from left to right; at any given
time, the collector(s) that are active will be drawn with a horizontal bar.
You can observe the CPU behavior within a frame by reading the graph from left
to right. You may find it useful to select &#8220;pause&#8221; from the Speed pulldown
menu to freeze the graph on just one frame while you read it.</p>
<p>Note that the piano roll chart shows time spent within the frame on the
horizontal axis, instead of the vertical axis, as it is on the strip charts.
Thus, the guide bars on the piano roll chart are vertical lines instead of
horizontal lines, and they may be dragged in from the left or the right sides
(instead of from the top or bottom, as on the strip charts). Apart from this
detail, these are the same guide bars that appear on the strip charts.</p>
<p>The piano roll chart may be created from the Graphs pulldown menu.</p>
</div>
<div class="section" id="additional-threads">
<h3>Additional threads<a class="headerlink" href="#additional-threads" title="Permalink to this headline">¶</a></h3>
<p>If the panda client has multiple threads that generate PStats data, the PStats
server can open up graphs for these threads as well. Each separate thread is
considered unrelated to the main thread, and may have the same or an
independent frame rate. Each separate thread will be given its own pulldown
menu to create graphs associated with that thread; these auxiliary thread
menus will appear on the menu bar following the Graphs menu. At the time of
this writing, support for multiple threads within the PStats graph is largely
theoretical and untested.</p>
</div>
<div class="section" id="color-and-other-optional-collector-properties">
<h3>Color and Other Optional Collector Properties<a class="headerlink" href="#color-and-other-optional-collector-properties" title="Permalink to this headline">¶</a></h3>
<p>If you do not specify a color for a particular collector, it will be assigned
a random color at runtime. At present, the only way to specify a color is to
modify panda/src/pstatclient/pStatProperties.cxx, and add a line to the table
for your new collector(s). You can also define additional properties here such
as a suggested initial scale for the graph and, for non-time-based collectors,
a unit name and/or scale factor. The order in which these collectors are
listed in this table is also relevant; they will appear in the same order on
the graphs. The first column should be set to 1 for your new collectors unless
you wish them to be disabled by default. You must recompile the client (but
not the server) to reflect changes to this table.</p>
</div>
</div>
<div class="section" id="how-to-define-your-own-collectors">
<h2>HOW TO DEFINE YOUR OWN COLLECTORS<a class="headerlink" href="#how-to-define-your-own-collectors" title="Permalink to this headline">¶</a></h2>
<p>The PStats client code is designed to be generic enough to allow users to
define their own collectors to time any arbitrary blocks of code (or record
additional non-time-based data), from either the C++ or the Python level.</p>
<p>The general idea is to create a PStatCollector for each separate block of code
you wish to time. The name which is passed to the PStatCollector constructor
is a unique identifier: all collectors that share the same name are deemed to
be the same collector.</p>
<p>Furthermore, the collector&#8217;s name can be used to define the hierarchical
relationship of each collector with other existing collectors. To do this,
prefix the collector&#8217;s name with the name of its parent(s), followed by a
colon separator. For instance, PStatCollector(&#8220;Draw:Flip&#8221;) defines a collector
named &#8220;Flip&#8221;, which is a child of the &#8220;Draw&#8221; collector, defined elsewhere.</p>
<p>You can also define a collector as a child of another collector by giving the
parent collector explicitly followed by the name of the child collector alone,
which is handy for dynamically-defined collectors. For instance,
PStatCollector(draw, &#8220;Flip&#8221;) defines the same collector named above, assuming
that draw is the result of the PStatCollector(&#8220;Draw&#8221;) constructor.</p>
<p>Once you have a collector, simply bracket the region of code you wish to time
with collector.start() and collector.stop(). It is important to ensure that
each call to start() is matched by exactly one call to stop(). If you are
programming in C++, it is highly recommended that you use the PStatTimer class
to make these calls automatically, which guarantees the correct pairing; the
PStatTimer&#8217;s constructor calls start() and its destructor calls stop(), so you
may simply define a PStatTimer object at the beginning of the block of code
you wish to time. If you are programming in Python, you must call start() and
stop() explicitly.</p>
<p>When you call start() and there was another collector already started, that
previous collector is paused until you call the matching stop() (at which time
the previous collector is resumed). That is, time is accumulated only towards
the collector indicated by the innermost start() .. stop() pair.</p>
<p>Time accumulated towards any collector is also counted towards that
collector&#8217;s parent, as defined in the collector&#8217;s constructor (described
above).</p>
<p>It is important to understand the difference between collectors nested
implicitly by runtime start/stop invocations, and the static hierarchy
implicit in the collector definition. Time is accumulated in parent collectors
according to the statically-defined parents of the innermost active collector
only, without regard to the runtime stack of paused collectors.</p>
<p>For example, suppose you are in the middle of processing the &#8220;Draw&#8221; task and
have therefore called start() on the &#8220;Draw&#8221; collector. While in the middle of
processing this block of code, you call a function that has its own collector
called &#8220;Cull:Sort&#8221;. As soon as you start the new collector, you have paused
the &#8220;Draw&#8221; collector and are now accumulating time in the &#8220;Cull:Sort&#8221;
collector. Once this new collector stops, you will automatically return to
accumulating time in the &#8220;Draw&#8221; collector. The time spent within the nested
&#8220;Cull:Sort&#8221; collector will be counted towards the &#8220;Cull&#8221; total time, not the
&#8220;Draw&#8221; total time.</p>
<p>If you wish to collect the time data for functions, a simple decorator pattern
can be used below, as below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">panda3d.core</span> <span class="kn">import</span> <span class="n">PStatCollector</span>
<span class="k">def</span> <span class="nf">pstat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">collectorName</span> <span class="o">=</span> <span class="s2">&quot;Debug:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;custom_collectors&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">collectorName</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">pstat</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="p">[</span><span class="n">collectorName</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="p">[</span><span class="n">collectorName</span><span class="p">]</span> <span class="o">=</span> <span class="n">PStatCollector</span><span class="p">(</span><span class="n">collectorName</span><span class="p">)</span>
            <span class="n">pstat</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="p">[</span><span class="n">collectorName</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="p">[</span><span class="n">collectorName</span><span class="p">]</span> <span class="o">=</span> <span class="n">PStatCollector</span><span class="p">(</span><span class="n">collectorName</span><span class="p">)</span>
        <span class="n">pstat</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">custom_collectors</span><span class="p">[</span><span class="n">collectorName</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">doPstat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="n">pstat</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">returned</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="n">pstat</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">returned</span>
    <span class="n">doPstat</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">doPstat</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__dict__</span>
    <span class="n">doPstat</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__doc__</span>
    <span class="k">return</span> <span class="n">doPstat</span>
</pre></div>
</div>
<p>To use it, either save the function to a file and import it into the script
you wish to debug. Then use it as a decorator on the function you wish to
time. A collection named Debug will appear in the Pstats server with the
function as its child.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pstat_debug</span> <span class="kn">import</span> <span class="n">pstat</span>

<span class="nd">@pstat</span>
<span class="k">def</span> <span class="nf">myLongRunFunction</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; This function does something long &quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="how-it-works-what-s-actually-happening">
<h2>HOW IT WORKS (What&#8217;s actually happening)<a class="headerlink" href="#how-it-works-what-s-actually-happening" title="Permalink to this headline">¶</a></h2>
<p>The PStats code is divided into two main parts: the client code and the server
code.</p>
<div class="section" id="the-pstats-client">
<h3>The PStats Client<a class="headerlink" href="#the-pstats-client" title="Permalink to this headline">¶</a></h3>
<p>The client code is in panda/src/pstatclient, and is available to run in every
Panda client unless it is compiled out. (It will be compiled out if OPTIMIZE
is set to level 4, unless DO_PSTATS is also explicitly set to non-empty. It
will also be compiled out if NSPR is not available, since both client and
server depend on the NSPR library to exchange data, even when running the
server on the same machine as the client.)</p>
<p>The client code is designed for minimal runtime overhead when it is compiled
in but not enabled (that is, when the client is not in contact with a PStats
server), as well as when it is enabled (when the client is in contact with a
PStats server). It is also designed for zero runtime overhead when it is
compiled out.</p>
<p>There is one global PStatClient class object, which manages all of the
communications on the client side. Each PStatCollector is simply an index into
an array stored within the PStatClient object, although the interface is
intended to hide this detail from the programmer.</p>
<p>Initially, before the PStatClient has established a connection, calls to
start() and stop() simply return immediately.</p>
<p>When you call PStatClient.connect(), the client attempts to contact the
PStatServer via a TCP connection to the hostname and port named in the
pstats-host and pstats-port Config.prc variables, respectively. (The default
hostname and port are localhost and 5185.) You can also pass in a specific
hostname and/or port to the connect() call. Upon successful connection and
handshake with the server, the PStatClient sends a list of the available
collectors, along with their names, colors, and hierarchical relationships, on
the TCP channel.</p>
<p>Once connected, each call to start() and stop() adds a collector number and
timestamp to an array maintained by the PStatClient. At the end of each frame,
the PStatClient boils this array into a datagram for shipping to the server.
Each start() and stop() event requires 6 bytes; if the resulting datagram will
fit within a UDP packet (1K bytes, or about 84 start/stop pairs), it is sent
via UDP; otherwise, it is sent on the TCP channel. (Some fraction of the
packets that are eligible for UDP, from 0% to 100%, may be sent via TCP
instead; you can specify this with the pstats-tcp-ratio Config.prc variable.)</p>
<p>Also, to prevent flooding the network and/or overwhelming the PStats server,
only so many frames of data will be sent per second. This parameter is
controlled by the pstats-max-rate Config.prc variable and is set to 30 by
default. (If the packets are larger than 1K, the max transmission rate is also
automatically reduced further in proportion.) If the frame rate is higher than
this limit, some frames will simply not be transmitted. The server is designed
to cope with missing frames and will assume missing frames are similar to
their neighbors.</p>
<p>The server does all the work of analyzing the data after that. The client&#8217;s
next job is simply to clear its array and prepare itself for the next frame.</p>
</div>
<div class="section" id="the-pstats-server">
<h3>The PStats Server<a class="headerlink" href="#the-pstats-server" title="Permalink to this headline">¶</a></h3>
<p>The generic server code is in pandatool/src/pstatserver, and the GUI-specific
server code is in pandatool/src/gtk-stats and pandatool/src/win-stats, for
Unix and Windows, respectively. (There is also an OS-independent text-stats
subdirectory, which builds a trivial PStats server that presents a
scrolling-text interface. This is mainly useful as a proof of technology
rather than as a usable tool.)</p>
<p>The GUI-specific code is the part that manages the interaction with the user
via the creation of windows and the handling of mouse input, etc.; most of the
real work of interpreting the data is done in the generic code in the
pstatserver directory.</p>
<p>The PStatServer owns all of the connections, and interfaces with the NSPR
library to communicate with the clients. It listens on the specified port for
new connections, using the pstats-port Config.prc variable to determine the
port number (this is the same variable that specifies the port to the client).
Usually you can leave this at its default value of 5185, but there may be some
cases in which that port is already in use on a particular machine (for
instance, maybe someone else is running another PStats server on another
display of the same machine).</p>
<p>Once a connection is received, it creates a PStatMonitor class (this class is
specialized for each of the different GUI variants) that handles all the data
for this particular connection. In the case of the windows pstats.exe program,
each new monitor instance is represented by a new toplevel window. Multiple
monitors can be active at once.</p>
<p>The work of digesting the data from the client is performed by the PStatView
class, which analyzes the pattern of start and stop timestamps, along with the
relationship data of the various collectors, and boils it down into a list of
the amount of time spent in each collector per frame.</p>
<p>Finally, a PStatStripChart or PStatPianoRoll class object defines the actual
graph output of colored lines and bars; the generic versions of these include
virtual functions to do the actual drawing (the GUI specializations of these
redefine these methods to make the appropriate calls).</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="the-rigid-body-combiner.html" class="btn btn-neutral float-right" title="The Rigid Body Combiner" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basic-performance-diagnostics.html" class="btn btn-neutral" title="Basic Performance Diagnostics" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Panda3D.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.10.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>